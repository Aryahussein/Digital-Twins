import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, simpledialog
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import random

# ==========================================
# 1. CORE SOLVER LOGIC (Modified for Monte Carlo)
# ==========================================
def parse_value(value_str):
    multipliers = {'k': 1e3, 'm': 1e-3, 'u': 1e-6, 'n': 1e-9, 'p': 1e-12, 'M': 1e6}
    value_str = value_str.lower().strip()
    if value_str[-1] in multipliers:
        return float(value_str[:-1]) * multipliers[value_str[-1]]
    return float(value_str)

def parse_netlist(file_path):
    """Parses file and returns components. Now stores 'original_value' for randomization."""
    components = {}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('*') or line.startswith('['):
                continue
            tokens = line.split()
            try:
                n3, n4 = 0, 0
                if len(tokens) == 4: # R, I
                    name, n1, n2, val_str = tokens[0], tokens[1], tokens[2], tokens[3]
                    n1, n2 = int(n1), int(n2)
                elif len(tokens) == 6: # G (VCCS)
                    name, n1, n2, n3, n4, val_str = tokens[0], tokens[1], tokens[2], tokens[3], tokens[4], tokens[5]
                    n1, n2, n3, n4 = int(n1), int(n2), int(n3), int(n4)
                else:
                    continue
                
                value = parse_value(val_str)
                # Store nominal value separately so we can randomize from it repeatedly
                components[name] = {"n1": n1, "n2": n2, "n3": n3, "n4": n4, 
                                    "value": value, "nominal_value": value}
            except ValueError:
                continue
    return components

def build_node_index(components):
    nodes = set()
    for comp in components.values():
        if comp["n1"] != 0: nodes.add(comp["n1"])
        if comp["n2"] != 0: nodes.add(comp["n2"])
        if comp["n3"] != 0: nodes.add(comp["n3"])
        if comp["n4"] != 0: nodes.add(comp["n4"])
    node_list = sorted(list(nodes))
    return {node: idx for idx, node in enumerate(node_list)}, len(node_list)

def invert_node_index(node_index):
    return {i: node for node, i in node_index.items()}

def generate_stamps(components, node_index):
    N = len(node_index)
    Y = lil_matrix((N, N), dtype=float)
    I = np.zeros(N)

    for name, comp in components.items():
        n1, n2, n3, n4, val = comp["n1"], comp["n2"], comp["n3"], comp["n4"], comp["value"]
        
        if name.upper().startswith("R"):
            if val <= 1e-12: continue # Avoid division by zero
            g = 1.0 / val
            if n1 != 0: Y[node_index[n1], node_index[n1]] += g
            if n2 != 0: Y[node_index[n2], node_index[n2]] += g
            if n1 != 0 and n2 != 0:
                Y[node_index[n1], node_index[n2]] -= g
                Y[node_index[n2], node_index[n1]] -= g
        elif name.upper().startswith("I"):
            if n1 != 0: I[node_index[n1]] -= val
            if n2 != 0: I[node_index[n2]] += val
        elif name.upper().startswith("G"):
            if n1 != 0:
                if n3 != 0: Y[node_index[n1], node_index[n3]] += val
                if n4 != 0: Y[node_index[n1], node_index[n4]] -= val
            if n2 != 0:
                if n3 != 0: Y[node_index[n2], node_index[n3]] -= val
                if n4 != 0: Y[node_index[n2], node_index[n4]] += val

    return Y.tocsr(), I

def solve_system(components, node_index, N):
    Y, I = generate_stamps(components, node_index)
    V = spsolve(Y, I)
    
    index_node = invert_node_index(node_index)
    voltages = {0: 0.0}
    for i, v in enumerate(V):
        voltages[index_node[i]] = v
    return voltages

# ==========================================
# 2. GUI INTERFACE (With Monte Carlo)
# ==========================================
class CircuitApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Python Monte Carlo Circuit Solver")
        self.root.geometry("1000x600")
        
        # --- LEFT PANEL: Controls ---
        frame_left = tk.Frame(root, width=350, bg="#f0f0f0", padx=10, pady=10)
        frame_left.pack(side=tk.LEFT, fill=tk.Y)
        
        tk.Label(frame_left, text="Circuit Solver", font=("Arial", 16, "bold"), bg="#f0f0f0").pack(pady=10)
        
        # File Loading
        tk.Button(frame_left, text="Load Netlist", command=self.load_file, 
                  font=("Arial", 11), bg="#e1e1e1").pack(fill=tk.X, pady=5)
        self.lbl_filename = tk.Label(frame_left, text="No file selected", fg="gray", bg="#f0f0f0")
        self.lbl_filename.pack()

        # Separator
        tk.Frame(frame_left, height=2, bd=1, relief=tk.SUNKEN).pack(fill=tk.X, pady=15)
        
        # Monte Carlo Controls
        tk.Label(frame_left, text="Monte Carlo Settings", font=("Arial", 12, "bold"), bg="#f0f0f0").pack(anchor="w")
        
        frame_tol = tk.Frame(frame_left, bg="#f0f0f0")
        frame_tol.pack(fill=tk.X, pady=5)
        tk.Label(frame_tol, text="Resistor Tolerance (%):", bg="#f0f0f0").pack(side=tk.LEFT)
        self.ent_tolerance = tk.Entry(frame_tol, width=10)
        self.ent_tolerance.insert(0, "5") # Default 5%
        self.ent_tolerance.pack(side=tk.RIGHT)
        
        frame_runs = tk.Frame(frame_left, bg="#f0f0f0")
        frame_runs.pack(fill=tk.X, pady=5)
        tk.Label(frame_runs, text="Number of Runs:", bg="#f0f0f0").pack(side=tk.LEFT)
        self.ent_runs = tk.Entry(frame_runs, width=10)
        self.ent_runs.insert(0, "1000")
        self.ent_runs.pack(side=tk.RIGHT)
        
        self.btn_mc = tk.Button(frame_left, text="ðŸŽ² Run Monte Carlo Analysis", 
                                command=self.run_monte_carlo, state=tk.DISABLED,
                                font=("Arial", 11, "bold"), bg="#d1e7dd", fg="#0f5132")
        self.btn_mc.pack(fill=tk.X, pady=15)

        # Output Box
        tk.Label(frame_left, text="Output Log:", bg="#f0f0f0").pack(anchor="w")
        self.txt_output = scrolledtext.ScrolledText(frame_left, width=40, height=15, font=("Consolas", 9))
        self.txt_output.pack(fill=tk.BOTH, expand=True)

        # --- RIGHT PANEL: Plots ---
        self.frame_right = tk.Frame(root, bg="white")
        self.frame_right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.fig, self.ax = plt.subplots(figsize=(5, 4))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.frame_right)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # State variables
        self.current_components = None
        self.node_index = None
        self.N = 0
        self.file_path = None

    def load_file(self):
        self.file_path = filedialog.askopenfilename(filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if not self.file_path: return
        
        self.lbl_filename.config(text=f"Loaded: {self.file_path.split('/')[-1]}")
        
        try:
            # Parse and Solve Once (Nominal)
            self.current_components = parse_netlist(self.file_path)
            if not self.current_components: raise ValueError("No components found.")
            
            self.node_index, self.N = build_node_index(self.current_components)
            voltages = solve_system(self.current_components, self.node_index, self.N)
            
            # Display Nominal Results
            self.log(f"--- Nominal Analysis ---\nFile: {self.file_path.split('/')[-1]}")
            for n in sorted(voltages):
                self.log(f"Node {n}: {voltages[n]:.4f} V")
            
            # Enable MC Button
            self.btn_mc.config(state=tk.NORMAL)
            
            # Plot Bar Chart
            self.plot_nominal(voltages)
            
        except Exception as e:
            messagebox.showerror("Error", str(e))
            self.log(f"Error: {str(e)}")

    def run_monte_carlo(self):
        if not self.current_components: return
        
        try:
            tolerance = float(self.ent_tolerance.get()) / 100.0
            runs = int(self.ent_runs.get())
        except ValueError:
            messagebox.showerror("Input Error", "Please enter valid numbers for Tolerance and Runs.")
            return

        # Ask user which node to track
        target_node = simpledialog.askinteger("Select Node", "Which Node # do you want to track statistics for?")
        if target_node is None: return # Cancelled
        
        # Map target node to internal index check
        if target_node not in self.node_index and target_node != 0:
            messagebox.showerror("Error", f"Node {target_node} does not exist in this circuit.")
            return
            
        self.log(f"\n--- Starting Monte Carlo ({runs} runs) ---")
        self.log(f"Target: Node {target_node}, Tolerance: {tolerance*100}%")
        
        results = []
        
        # --- MONTE CARLO LOOP ---
        import copy
        # Work on a deep copy so we don't mess up original nominal values
        temp_components = copy.deepcopy(self.current_components)
        
        for i in range(runs):
            # Randomize Resistors
            for name, comp in temp_components.items():
                if name.upper().startswith("R"):
                    # Uniform distribution: Nominal +/- Tolerance
                    nominal = comp["nominal_value"]
                    delta = nominal * tolerance
                    # Random float between (Nominal - delta) and (Nominal + delta)
                    comp["value"] = random.uniform(nominal - delta, nominal + delta)
            
            # Solve
            try:
                voltages = solve_system(temp_components, self.node_index, self.N)
                results.append(voltages.get(target_node, 0.0))
            except Exception:
                continue # Skip singular matrix errors if they happen randomly
        
        # --- STATISTICS ---
        avg_v = np.mean(results)
        std_v = np.std(results)
        min_v = np.min(results)
        max_v = np.max(results)
        
        self.log(f"Mean: {avg_v:.4f} V")
        self.log(f"Std Dev: {std_v:.4f} V")
        self.log(f"Min: {min_v:.4f} V | Max: {max_v:.4f} V")
        
        # --- PLOT HISTOGRAM ---
        self.plot_histogram(results, target_node, runs)

    def plot_nominal(self, voltages):
        self.ax.clear()
        nodes = sorted(voltages.keys())
        vals = [voltages[n] for n in nodes]
        bars = self.ax.bar(nodes, vals, color='skyblue', edgecolor='black')
        
        self.ax.set_title("Nominal Node Voltages")
        self.ax.set_xlabel("Node")
        self.ax.set_ylabel("Voltage (V)")
        self.ax.set_xticks(nodes)
        self.ax.grid(axis='y', alpha=0.3)
        self.canvas.draw()

    def plot_histogram(self, data, node_num, runs):
        self.ax.clear()
        
        # Histogram
        self.ax.hist(data, bins=30, color='orange', edgecolor='black', alpha=0.7)
        
        # Mean Line
        mean_val = np.mean(data)
        self.ax.axvline(mean_val, color='red', linestyle='dashed', linewidth=2, label=f'Mean: {mean_val:.3f}V')
        
        self.ax.set_title(f"Monte Carlo Distribution: Node {node_num}\n({runs} runs)")
        self.ax.set_xlabel("Voltage (V)")
        self.ax.set_ylabel("Frequency")
        self.ax.legend()
        self.ax.grid(alpha=0.3)
        self.canvas.draw()

    def log(self, text):
        self.txt_output.insert(tk.END, text + "\n")
        self.txt_output.see(tk.END)

if __name__ == "__main__":
    root = tk.Tk()
    app = CircuitApp(root)
    root.mainloop()
