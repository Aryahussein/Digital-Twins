import numpy as np
import re

def parse_value(value_str):
    """
    Parses SPICE-like value strings with suffixes (e.g., '2.2k', '30m').
    """
    multipliers = {
        'T': 1e12, 'G': 1e9, 'Meg': 1e6, 'k': 1e3,
        'm': 1e-3, 'u': 1e-6, 'n': 1e-9, 'p': 1e-12, 'f': 1e-15
    }
    
    # Regex to separate number from suffix
    match = re.match(r"([0-9\.]+)([a-zA-Z]*)", value_str)
    if not match:
        return float(value_str)
    
    val, suffix = match.groups()
    multiplier = multipliers.get(suffix, 1.0)
    return float(val) * multiplier

def generate_nodal_equations(netlist_text):
    lines = netlist_text.strip().split('\n')
    
    # 1. Identify all unique nodes
    nodes = set()
    for line in lines:
        parts = line.split()
        if len(parts) >= 4:
            nodes.add(parts[1])
            nodes.add(parts[2])
            
    # Remove ground node '0' and sort the rest to map them to matrix indices
    if '0' in nodes:
        nodes.remove('0')
    node_list = sorted(list(nodes))
    node_map = {name: i for i, name in enumerate(node_list)}
    N = len(node_list)

    # Initialize matrices
    Y = np.zeros((N, N))
    I_vec = np.zeros(N)

    print(f"Detected Nodes (excluding Ground): {node_list}")
    print("-" * 40)

    # 2. Populate Matrices (Stamping Method)
    for line in lines:
        parts = line.split()
        type = parts[0][0].upper() # R or I
        n1_name = parts[1]
        n2_name = parts[2]
        value = parse_value(parts[3])

        n1 = node_map.get(n1_name, -1) # -1 if ground
        n2 = node_map.get(n2_name, -1) # -1 if ground

        if type == 'R':
            conductance = 1.0 / value
            # Diagonal elements (Sum of conductances connected to node)
            if n1 != -1: Y[n1, n1] += conductance
            if n2 != -1: Y[n2, n2] += conductance
            
            # Off-diagonal elements (Negative conductance between nodes)
            if n1 != -1 and n2 != -1:
                Y[n1, n2] -= conductance
                Y[n2, n1] -= conductance

        elif type == 'I':
            # SPICE convention: Current flows from n1 to n2
            # For Nodal Analysis (KCL): Sum of currents LEAVING = 0
            # Alternatively: Y*V = I_injected (Currents ENTERING nodes)
            
            # Current leaves n1 -> Subtract from n1
            if n1 != -1: I_vec[n1] -= value
            
            # Current enters n2 -> Add to n2
            if n2 != -1: I_vec[n2] += value

    return node_list, Y, I_vec

# --- Input Netlist ---
netlist = """
I1 0 1 30m
R1 1 2 100
R2 2 0 2.2k
R3 2 3 470
R4 3 0 1.5k
R5 1 3 3.3k
"""

# --- Execution ---
nodes, Y, I = generate_nodal_equations(netlist)

# --- Output Formatting ---
print("Nodal Admittance Matrix (Y):")
print(Y)
print("\nCurrent Vector (I):")
print(I)

print("\nFinal Equation Form [Y] * [V] = [I]:")
for i in range(len(nodes)):
    row_str = "  ".join([f"{val:10.5f}" for val in Y[i]])
    print(f"| {row_str} |   | V{nodes[i]} |   | {I[i]:.5f} |")
