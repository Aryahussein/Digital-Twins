# Goal: take an arbitrary circuit (netlist of elements) and produce
# (1) node equations in MNA form and (2) element “stamps” into the global matrix.

function build_mna(netlist):
    # --- 1) Parse + normalize ---
    elems = parse_netlist(netlist)                 # each: type, n+, n-, value, params...
    nodes = collect_all_nodes(elems)
    ground = choose_ground(nodes)                  # usually node "0" / "gnd"
    node_id = assign_indices(nodes \ {ground})     # map node name -> 0..(N-1)

    # --- 2) Discover extra unknowns (currents through voltage-defined elements) ---
    # MNA unknown vector x = [v_node0..v_nodeN-1, i_aux0..i_auxM-1]^T
    aux = []                                       # voltage sources, inductors (if using i_L), VCVS/CCVS, etc.
    for e in elems:
        if needs_aux_current_unknown(e):
            e.aux_index = aux.length
            aux.append(e)

    N = node_id.count
    M = aux.length
    A = zeros((N+M), (N+M))                        # global conductance-like matrix
    z = zeros((N+M), 1)                            # RHS vector

    # helper: translate node name to matrix row/col index; return NONE for ground
    function k(node_name):
        if node_name == ground: return NONE
        return node_id[node_name]

    # helper: add to A safely with ground checks
    function addA(i, j, val):
        if i != NONE and j != NONE:
            A[i, j] += val

    function addz(i, val):
        if i != NONE:
            z[i] += val

    # --- 3) Stamp each element ---
    for e in elems:
        a = k(e.n_plus)
        b = k(e.n_minus)

        switch e.type:

            case "R":                              # resistor between a-b, g=1/R
                g = 1.0 / e.value
                addA(a, a, +g); addA(b, b, +g)
                addA(a, b, -g); addA(b, a, -g)

            case "I":                              # current source from n+ to n- (arrow + -> -)
                I = e.value
                addz(a, -I)                        # leaving node a
                addz(b, +I)

            case "G":                              # VCCS: i = g*(v(c+)-v(c-)) injected from a->b
                c = k(e.ctrl_plus); d = k(e.ctrl_minus)
                g = e.value
                addA(a, c, +g); addA(a, d, -g)
                addA(b, c, -g); addA(b, d, +g)

            case "V":                              # independent voltage source v(a)-v(b)=V
                m = N + e.aux_index                # row/col for its current unknown
                V = e.value
                # KCL coupling (incidence)
                addA(a, m, +1); addA(b, m, -1)
                addA(m, a, +1); addA(m, b, -1)
                # constraint RHS
                addz(m, V)

            case "E":                              # VCVS: v(a)-v(b) = mu*(v(c)-v(d))
                m = N + e.aux_index
                mu = e.gain
                c = k(e.ctrl_plus); d = k(e.ctrl_minus)
                addA(a, m, +1); addA(b, m, -1)
                addA(m, a, +1); addA(m, b, -1)
                addA(m, c, -mu); addA(m, d, +mu)

            case "F":                              # CCCS: i(a->b) = beta * i(vsense)
                # requires a named sensing voltage source vsense with aux current index
                beta = e.gain
                s = N + lookup_aux_index(e.vsense_name)
                addA(a, s, +beta)
                addA(b, s, -beta)

            case "H":                              # CCVS: v(a)-v(b) = r * i(vsense)
                m = N + e.aux_index
                r = e.transresistance
                s = N + lookup_aux_index(e.vsense_name)
                addA(a, m, +1); addA(b, m, -1)
                addA(m, a, +1); addA(m, b, -1)
                addA(m, s, -r)

            case "C":                              # capacitor: use companion model (transient) or ignore for DC
                if analysis == "DC":
                    # open circuit -> no stamp
                    continue
                else:
                    # backward-Euler: i = C*(v_k - v_{k-1})/dt => conductance g=C/dt + history current
                    g = e.value / dt
                    ih = g * e.v_prev              # history term for RHS (implementation-dependent sign)
                    addA(a, a, +g); addA(b, b, +g)
                    addA(a, b, -g); addA(b, a, -g)
                    addz(a, +ih); addz(b, -ih)

            case "L":                              # inductor: needs aux current (transient) or short for DC
                if analysis == "DC":
                    # short circuit: enforce v(a)=v(b) with an aux current like a 0V source
                    m = N + e.aux_index
                    addA(a, m, +1); addA(b, m, -1)
                    addA(m, a, +1); addA(m, b, -1)
                    addz(m, 0)
                else:
                    # backward-Euler: v = L*(i_k - i_{k-1})/dt => stamp like a voltage source with series R
                    m = N + e.aux_index
                    r = e.value / dt               # "companion resistance" (actually L/dt in equation form)
                    addA(a, m, +1); addA(b, m, -1)
                    addA(m, a, +1); addA(m, b, -1)
                    addA(m, m, -r)
                    addz(m, -r * e.i_prev)

            default:
                error("Unsupported element type")

    # --- 4) Produce node equations + stamps ---
    # Node equations are simply A*x = z; each element stamp is the local contributions you added.
    return (A, z, node_id, aux)

# Optional: pretty-print symbolic equations per node from A and z
function emit_node_equations(A, z, node_id, aux):
    for each row r in 0..A.rows-1:
        lhs = sum_j( A[r,j] * x_j )
        print(lhs, "=", z[r])
