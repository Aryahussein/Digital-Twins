# ---------- Basic types ----------
[Types and globals]
Element:
    type        # 'R','C','L','I','V','G','E','F','H',...
    name        # string, e.g. "R1"
    nodes[]     # list of node names, order depends on element type
    params      # dict: { "value": ..., "gain": ..., etc. }

Netlist:
    elements[]  # list of Element

Circuit:
    netlist     # Netlist
    node_index  # map node_name -> integer index, ground = 0
    branch_index# map element_name -> integer index for branch current
    Nvars       # total number of unknowns (node voltages + branch currents)

AnalysisOptions:
    type        # "DC" or "TRAN"
    t_start, t_stop, dt   # for transient
    max_newton_iter       # for nonlinears (if you add them)
    tol                   # Newton / linear solver tolerance

run_simulation(netlist_file, options):
    circuit = build_circuit(netlist_file)

    if options.type == "DC":
        x_dc = solve_dc(circuit)
        return x_dc

    if options.type == "TRAN":
        times, X = solve_transient(circuit, options)
        return times, X



[Main high‑level entry points]

run_simulation(netlist_file, options):
    circuit = build_circuit(netlist_file)

    if options.type == "DC":
        x_dc = solve_dc(circuit)
        return x_dc

    if options.type == "TRAN":
        times, X = solve_transient(circuit, options)
        return times, X

[Build circuit (parse + index + static matrices)]
build_circuit(netlist_file):
    netlist = parse_netlist(netlist_file)
    node_index, branch_index, N = build_indices(netlist)
    circuit = Circuit()
    circuit.netlist      = netlist
    circuit.node_index   = node_index
    circuit.branch_index = branch_index
    circuit.Nvars        = N
    return circuit

[Netlist parsing]

parse_netlist(filename):
    elements = []
    open filename as file
    for each line in file:
        line = strip_comments_and_whitespace(line)
        if line is empty:
            continue

        tokens = split_whitespace(line)
        name   = tokens[0]
        etype  = first_char(name)               # R,C,L,V,I,G,E,F,H,...

        if etype in {'R','C','L','I','V'}:
            # minimal: name n1 n2 value
            n1   = tokens[1]
            n2   = tokens[2]
            val  = parse_value(tokens[3])       # 10k, 1u, etc.

            e = Element()
            e.type   = etype
            e.name   = name
            e.nodes  = [n1, n2]
            e.params = { "value": val }

            elements.append(e)

        else if etype in {... more device types ...}:
            # parse according to that syntax
            # set e.nodes and e.params appropriately
            ...

    netlist = Netlist()
    netlist.elements = elements
    return netlist

[Index building (nodes + branch currents)]

build_indices(netlist):
    node_set = set()
    node_set.add("0")                   # ground

    # collect all node names
    for e in netlist.elements:
        for n in e.nodes:
            node_set.add(n)

    # ground = 0, other nodes = 1..Nnode
    node_index = {}
    node_index["0"] = 0

    non_ground = sorted(node_set - {"0"})
    for i, nname in enumerate(non_ground):
        node_index[nname] = i + 1

    next_var = 1 + len(non_ground)      # first free index for branch currents

    branch_index = {}

    # assign current variables to any element that needs it
    for e in netlist.elements:
        if e.type in {'V','L','E','H'}:
            branch_index[e.name] = next_var
            next_var += 1

    N_total = next_var - 1
    return node_index, branch_index, N_total

[Matrix allocation helper]

allocate_matrices(N):
    G = zero_matrix(N, N)   # conductance / algebraic matrix
    C = zero_matrix(N, N)   # dynamic storage matrix
    b = zero_vector(N)      # RHS (sources)
    return G, C, b

[Assembling the linear system for one “load”]

assemble_linear_system(circuit, t, x_prev, xdot_prev, options):
    # x_prev, xdot_prev can be NULL for DC (no history needed)
    N = circuit.Nvars
    G, C, b = allocate_matrices(N)

    for each e in circuit.netlist.elements:
        stamp_element(e, G, C, b,
                      circuit.node_index,
                      circuit.branch_index,
                      t, x_prev, xdot_prev, options)

    return G, C, b

[Element stamp dispatcher]

stamp_element(e, G, C, b, node_index, branch_index,
              t, x_prev, xdot_prev, options):

    if e.type == 'R':
        stamp_R(e, G, node_index)

    elif e.type == 'C':
        stamp_C(e, C, node_index)

    elif e.type == 'L':
        stamp_L(e, G, C, node_index, branch_index)

    elif e.type == 'I':
        stamp_I(e, b, node_index, t)

    elif e.type == 'V':
        stamp_V(e, G, b, node_index, branch_index, t)

    # elif e.type in {'G','E','F','H', ...}:
    #     stamp_controlled_source(...)

    # elif e is nonlinear:
    #     compute linearized equivalent and stamp it (not shown here)



