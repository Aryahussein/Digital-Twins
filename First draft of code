import numpy as np
import re

class CircuitSolver:
    def __init__(self):
        self.nodes = set()
        self.components = []

    def parse_netlist(self, netlist_text):
        """Reads the netlist text block"""
        self.nodes = set()
        self.components = []
        
        lines = netlist_text.strip().split('\n')
        
        for line in lines:
            # Clean up the line
            line = line.strip()
            if not line: continue
            
            parts = line.split()
            name = parts[0].strip()
            
            # Skip header lines like "Branch type/name"
            # We only process lines starting with R (Resistor) or I (Current)
            
            if name.upper().startswith('R'): 
                # Format: Name Node1 Node2 Value
                n1, n2 = parts[1], parts[2]
                val = float(parts[3])
                
                # Store as Conductance (G = 1/R)
                self.components.append({'type': 'G', 'n1': n1, 'n2': n2, 'val': 1.0/val})
                self.nodes.update([n1, n2])

            elif name.upper().startswith('I'):
                # Format: Name NodeFrom NodeTo Value
                n_from, n_to = parts[1], parts[2]
                val = float(parts[3])
                
                self.components.append({'type': 'I', 'n1': n_from, 'n2': n_to, 'val': val})
                self.nodes.update([n_from, n_to])

    def solve(self):
        # 1. Map Nodes (Ground '0' is excluded from matrix)
        unique_nodes = sorted([n for n in self.nodes if str(n) != '0'])
        node_map = {name: i for i, name in enumerate(unique_nodes)}
        N = len(unique_nodes)
        
        if N == 0: return "No nodes found to solve."

        # Initialize Matrix Y and Vector J
        Y = np.zeros((N, N))
        J = np.zeros(N)
        
        # 2. Build Stamps
        for comp in self.components:
            i = node_map.get(comp['n1'], -1) if str(comp['n1']) != '0' else -1
            j = node_map.get(comp['n2'], -1) if str(comp['n2']) != '0' else -1
            val = comp['val']

            if comp['type'] == 'G':
                if i >= 0: Y[i, i] += val
                if j >= 0: Y[j, j] += val
                if i >= 0 and j >= 0:
                    Y[i, j] -= val
                    Y[j, i] -= val
            
            elif comp['type'] == 'I':
                if i >= 0: J[i] -= val 
                if j >= 0: J[j] += val 

        # 3. Solve Linear System
        try:
            V = np.linalg.solve(Y, J)
        except np.linalg.LinAlgError:
            return "Error: Circuit is unsolvable."

        # Format Results
        results = {name: V[idx] for name, idx in node_map.items()}
        results['0'] = 0.0 # Ground is always 0
        return results

# I used the textbook example netlist 
netlist_from_image = """
Branch From To Value
I1     0    1  1.0
R2     1    0  1.0
R3     1    2  1.0
R4     2    0  1.0
R5     2    3  1.0
R6     3    0  1.0
R7     3    4  1.0
R8     4    0  1.0
I9     0    4  1.0
"""

# --- RUN THE SOLVER ---
solver = CircuitSolver()
solver.parse_netlist(netlist_from_image)
voltages = solver.solve()

print("--- Calculated Node Voltages ---")
# Sort by node number for clean output
for node in sorted(voltages.keys()):
    print(f"Node {node}: {voltages[node]:.4f} V")
